import assert from 'assert';
import EthCrypto from 'eth-crypto';

import EthOTP from '../src/index';

let ethotp = new EthOTP();

describe('Get random phrase to use for message signing', () => {
  it('should return object with a `challenge` string object', () => {
    const a = ethotp.generateChallenge();
    assert.strictEqual(typeof a, "string");
  });

  it('should not return two `challenges` that are the same right after each other', () => {
    const a = ethotp.generateChallenge();
    const b = ethotp.generateChallenge();
    assert.notStrictEqual(a, b);
  });
});


describe('Checking phrase `challenges`', () => {
  it('should verify that `challenges` was actually generated by this', () => {
    const a = ethotp.generateChallenge();
    assert.strictEqual(ethotp._validateChallenge(a), true);
  });

  it('should not verify `challenges` that are not generated by this', () => {
    let a = ethotp.generateChallenge();
    a = a + "b";
    assert.strictEqual(ethotp._validateChallenge(a), false);
  });

  it('should not verify `challenges` that are previously validated', () => {
    const a = ethotp.generateChallenge();
    ethotp._validateChallenge(a);
    assert.strictEqual(ethotp._validateChallenge(a), false);
  });

  it('should not verify `challenges` that are are expired/timed-out', () => {
    const a = ethotp.generateChallenge();
    ethotp._validateChallenge(a);
    assert.strictEqual(ethotp._validateChallenge(a), false);
  });
});


describe('Verifying signed phrases from users', () => {
  const alice = EthCrypto.createIdentity();
  const msg = "whatever really";
  const signature = EthCrypto.sign(alice.privateKey, EthCrypto.hash.keccak256(msg));

  it('should verify that valid signatures are valid', () => {
    const payload = {
      message: msg,
      signature: signature,
      address: alice.address,
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, true);
  });

  it('should not verify tampered messages', () => {
    const payload = {
      message: msg + "a",
      signature: signature,
      address: alice.address,
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify 0 length messages', () => {
    const payload = {
      message: "",
      signature: signature,
      address: alice.address,
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify undefined messages', () => {
    const payload = {
      message: undefined,
      signature: signature,
      address: alice.address,
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify missing messages', () => {
    const payload = {
      signature: signature,
      address: alice.address,
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify tampered addresses', () => {
    const payload = {
      message: msg,
      signature: signature,
      address: alice.address + "a",
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify 0 length addresses', () => {
    const payload = {
      message: msg,
      signature: signature,
      address: "",
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify undefined addresses', () => {
    const payload = {
      message: msg,
      signature: signature,
      address: undefined,
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify missing addresses', () => {
    const payload = {
      message: msg,
      signature: signature,
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify tampered signatures', () => {
    let tamperedSig = signature.substr(0, signature.length - 5) + "aaaaa";
    const payload = {
      message: msg,
      signature: tamperedSig,
      address: alice.address,
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify 0 length signatures', () => {
    const payload = {
      message: msg,
      signature: "",
      address: alice.address,
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify undefined signatures', () => {
    const payload = {
      message: msg,
      signature: undefined,
      address: alice.address,
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify missing signatures', () => {
    const payload = {
      message: msg,
      address: alice.address,
    };
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify empty payload object', () => {
    const payload = {};
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify undefined payload object', () => {
    const payload = undefined;
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify incorrect type (string) payload object', () => {
    const payload = "lol";
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });

  it('should not verify incorrect type (number) payload object', () => {
    const payload = 12.1451;
    const result = ethotp._isVerifiedPayload(payload);
    assert.strictEqual(result, false);
  });
});


describe('Integration of all components', () => {
  it('should work haha :)', () => {
    const alice = EthCrypto.createIdentity();
    const challenge = ethotp.generateChallenge();
    const signature = EthCrypto.sign(alice.privateKey, EthCrypto.hash.keccak256(challenge));
    const payload = {
      message: challenge,
      signature: signature,
      address: alice.address,
    };

    assert.strictEqual(ethotp.validateAndVerifyChallengePayload(payload), true);
  });

  it('quick wont work check haha :(', () => {
    const alice = EthCrypto.createIdentity();
    const challenge = ethotp.generateChallenge();
    const signature = EthCrypto.sign(alice.privateKey, EthCrypto.hash.keccak256(challenge));
    const payload = {
      message: challenge + "a",
      signature: signature,
      address: alice.address,
    };

    assert.strictEqual(ethotp.validateAndVerifyChallengePayload(payload), false);
  });
});