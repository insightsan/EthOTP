import assert from 'assert';
import EthCrypto from 'eth-crypto';

import EthOTP from '../src/index';

let ethotp = new EthOTP();

describe('Get random phrase to use for message signing', () => {
  it('should return object with a `challenge` string object', () => {
    const a = ethotp.generateChallenge();
    assert.strictEqual(typeof a, "string");
  });

  it('should not return two `challenges` that are the same right after each other', () => {
    const a = ethotp.generateChallenge();
    const b = ethotp.generateChallenge();
    assert.notStrictEqual(a, b);
  });
});


describe('Checking phrase `challenges`', () => {
  it('should verify that `challenges` was actually generated by this', () => {
    const a = ethotp.generateChallenge();
    assert.strictEqual(ethotp._validateChallenge(a), true);
  });

  it('should not verify `challenges` that are not generated by this', () => {
    let a = ethotp.generateChallenge();
    a = a + "b";
    assert.strictEqual(ethotp._validateChallenge(a), false);
  });

  it('should not verify `challenges` that are previously validated', () => {
    const a = ethotp.generateChallenge();
    ethotp._validateChallenge(a);
    assert.strictEqual(ethotp._validateChallenge(a), false);
  });

  it('should not verify `challenges` that are are expired/timed-out', () => {
    const a = ethotp.generateChallenge();
    ethotp._validateChallenge(a);
    assert.strictEqual(ethotp._validateChallenge(a), false);
  });
});


describe('Verifying signed phrases from users', () => {
  const alice = EthCrypto.createIdentity();
  const msg = "whatever really";
  const sig = EthCrypto.sign(alice.privateKey, EthCrypto.hash.keccak256(msg));

  it('should verify that valid signatures are valid', () => {
    const message = msg;
    const signature = sig;
    const address = alice.address;

    const result = ethotp._isVerified(message, signature, address);
    assert.strictEqual(result, true);
  });

  it('should not verify tampered messages', () => {
    const message = msg + "a";
    const signature = sig;
    const address = alice.address;

    const result = ethotp._isVerified(message, signature, address);
    assert.strictEqual(result, false);
  });

  it('should not verify 0 length messages', () => {
    const message = "";
    const signature = sig;
    const address = alice.address;

    const result = ethotp._isVerified(message, signature, address);
    assert.strictEqual(result, false);
  });

  it('should not verify undefined messages', () => {
    const message = undefined;
    const signature = sig;
    const address = alice.address;

    const result = ethotp._isVerified(message, signature, address);
    assert.strictEqual(result, false);
  });

  it('should not verify tampered addresses', () => {
    const message = msg;
    const signature = sig;
    const address = alice.address + "a";

    const result = ethotp._isVerified(message, signature, address);
    assert.strictEqual(result, false);
  });

  it('should not verify 0 length addresses', () => {
    const message = msg;
    const signature = sig;
    const address = "";

    const result = ethotp._isVerified(message, signature, address);
    assert.strictEqual(result, false);
  });

  it('should not verify undefined addresses', () => {
    const message = msg;
    const signature = sig;
    const address = undefined;

    const result = ethotp._isVerified(message, signature, address);
    assert.strictEqual(result, false);
  });

  it('should not verify tampered signatures', () => {
    const message = msg;
    const tamperedSig = sig.substr(0, sig.length - 5) + "aaaaa";
    const address = alice.address;

    const result = ethotp._isVerified(message, tamperedSig, address);
    assert.strictEqual(result, false);
  });

  it('should not verify 0 length signatures', () => {
    const message = msg;
    const signature = "";
    const address = alice.address;

    const result = ethotp._isVerified(message, signature, address);
    assert.strictEqual(result, false);
  });

  it('should not verify undefined signatures', () => {
    const message = msg;
    const signature = undefined;
    const address = alice.address;

    const result = ethotp._isVerified(message, signature, address);
    assert.strictEqual(result, false);
  });
});

describe('Integration of all components', () => {
  it('should work haha :)', () => {
    const alice = EthCrypto.createIdentity();
    const challenge = ethotp.generateChallenge();
    const signature = EthCrypto.sign(alice.privateKey, EthCrypto.hash.keccak256(challenge));

    assert.strictEqual(ethotp.validateAndVerify(challenge, signature, alice.address), true);
  });

  it('quick wont work check haha :(', () => {
    const alice = EthCrypto.createIdentity();
    const challenge = ethotp.generateChallenge();
    const signature = EthCrypto.sign(alice.privateKey, EthCrypto.hash.keccak256(challenge));

    assert.strictEqual(ethotp.validateAndVerify(challenge + "a", signature, alice.address), false);
  });

  it('should fail when validation fails', () => {
    const alice = EthCrypto.createIdentity();
    const fakeChallenge = "lol not a real message";
    const signature = EthCrypto.sign(alice.privateKey, EthCrypto.hash.keccak256(fakeChallenge));

    assert.strictEqual(ethotp.validateAndVerify(fakeChallenge, signature, alice.address), false);
  });

  it('should fail when verification fails', () => {
    const alice = EthCrypto.createIdentity();
    const challenge = ethotp.generateChallenge();
    const signature = EthCrypto.sign(alice.privateKey, EthCrypto.hash.keccak256(challenge));

    assert.strictEqual(ethotp.validateAndVerify(challenge, signature, alice.address.substr(alice.address.length - 1) + "a"), false);
  });

});